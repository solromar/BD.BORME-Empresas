<?php

namespace App\Controller;

use App\Entity\Company;
use Spatie\PdfToText\Pdf;
use Psr\Log\LoggerInterface;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;
use App\Entity\CompanyInscription;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;

class ReadBormeController extends AbstractController
{
    private $projectDir;
    private $entityManager;
    private $processedFilesList = [];
    private $counter = 0;

    public static $clearCounter = 0;
    public const CLEAR_COUNTER_MAX_FILES = 50;
    
    const COMPANY_STATE = 'VIGENTE';
    const DATE_PATTERN = '/(Lunes|Martes|Miércoles|Jueves|Viernes|Sábado|Domingo)\s+(\d+)\s+de\s+(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)\s+de\s+(\d{4})/';
    const INSCRIPTION_PATTERN = '/^([0-9]+ - .*?)(?=\n[0-9]+ - |\z)/ms';
    const FILE_TYPE_HANDLERS = [
        'A' => 'handleFileTypeA',
        'B' => 'handleFileTypeB',
        'C' => 'handleFileTypeC',
        'S' => 'noFunc'
    ];

    public function __construct(public LoggerInterface $logger, ParameterBagInterface $parameterBag, EntityManagerInterface $entityManager)
    {
        $this->projectDir = $parameterBag->get('kernel.project_dir');
        $this->entityManager = $entityManager;
        $this->entityManager->getConnection()->getConfiguration()->setSQLLogger(null);
    }

    /**
     * @Route("/read/borme", name="app_read_borme")
     */
    public function index(): Response
    {
        $date = (new \DateTime())->format("m-d H:i");
        $this->logger->info("APP START AT: $date");
        
        $filePath = $this->projectDir . '/public/files/';
        $this->searchPdfsRecursively($filePath);

        return $this->json('Ok');
    }
    
    public function searchPdfsRecursively($directory)
    {
        ini_set('memory_limit', '2048M'); // Aumenta a 2048MB
        ignore_user_abort(true);

        $logsDir = '/home'; // For prod
        $filesystem = new Filesystem();
        $processedFilePath = $logsDir . '/processed_files.txt';
        $processedFilesDir = $logsDir . '/processed_files'; // Asegúrate de que este directorio exista
        $notProcessedFilesDir = $logsDir . '/not_processed_files'; // Asegúrate de que este directorio exista

        // Crear los directorios si no existen
        if (!$filesystem->exists($processedFilesDir)) {
            $filesystem->mkdir($processedFilesDir);
        }
        if (!$filesystem->exists($notProcessedFilesDir)) {
            $filesystem->mkdir($notProcessedFilesDir);
        }

        $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory));

        try {
            foreach ($iterator as $file) {
                if ($file->isFile() && strtolower($file->getExtension()) === 'pdf') {
                    $fileName = $file->getFilename();
                    
                    try {
                        // Intenta procesar el archivo
                        $this->processFile($file->getPath() . '/', $fileName);
                        $this->processedFilesList[] = $fileName;
                        // Si el archivo se procesa correctamente, se mueve a 'processed_files'
                        $destinationPath = $processedFilesDir . '/' . $fileName;
                        if (!$filesystem->exists($destinationPath)) {
                            $filesystem->rename($file->getRealPath(), $destinationPath);
                        }
                    } catch (\Exception $e) {
                        // Si hay un error, el archivo se añade a 'errorFilesList'
                        $this->getDoctrine()->resetManager();
                        // Y se mueve a 'not_processed_files'
                        $destinationPath = $notProcessedFilesDir . '/' . $fileName;
                        if (!$filesystem->exists($destinationPath)) {
                            $filesystem->rename($file->getRealPath(), $destinationPath);
                        }
                    }

                    $this->counter++;
                    if ($this->counter % self::CLEAR_COUNTER_MAX_FILES == 0) {
                        file_put_contents($processedFilePath, implode(PHP_EOL, $this->processedFilesList), FILE_APPEND);
                        $this->processedFilesList = [];
                        $this->entityManager->flush();
                        $this->entityManager->clear();

                        $this->counter = 0;
                    }
                }
            }
        } catch (\Throwable $th) {
            $this->logger->info("APP FATAL ERROR: " . $th->getMessage() . ". Line: " . $th->getLine());
        }
    }


    public function processFile($filePath, $fileName)
    {
        $pdfRoute = $filePath . $fileName;
        $textoDelPdf = $this->pdfToText($pdfRoute);
        $tipoArchivo = explode('-', $fileName)[1];

        if (array_key_exists($tipoArchivo, self::FILE_TYPE_HANDLERS)) {
            $handlerMethod = self::FILE_TYPE_HANDLERS[$tipoArchivo];

            if (method_exists($this, $handlerMethod)) {
                $this->$handlerMethod($textoDelPdf, $fileName);
            }
        }

        unset($textoDelPdf); // Libera la memoria eliminando la variable textoDelPdf
        set_time_limit(0);
    }

    public function handleFileTypeA($textoDelPdf, $fileName)
    {
        $inscription = '';

        if (preg_match('/^Actos inscritos\n([A-Z\/ÁÉÍÓÚÜ]+)\n/m', $textoDelPdf, $matches)) {
            $comercialRegistryConstitucion = $matches[1];
        }

        $this->findBormeVars_A_B($textoDelPdf, $inscriptionCategory, $inscriptions);
        $this->findGenericBormeSectionAndDate($textoDelPdf, $inscriptionSection ,$bormeDate);
        
        foreach ($inscriptions ?? [] as $key => $inscription) {
            if (preg_match('/^\d+\s-\s(.*)(\R|$)/m', $inscription, $matches)) {
                $companyName = $matches[1];
            } else {
                $companyName = 'Nombre no encontrado';
            }
            
            if (preg_match("/^\d+/m", $inscription, $matches)) {
                $inscriptionNumber = $matches[0];
            }

            $lines = explode("\n", $inscription);
            $secondLine = isset($lines[1]) ? $lines[1] : '';
            $inscriptionName = '';

            if (!empty($secondLine)) {
                $pattern = '/^[^\.|:]+/';
                if (preg_match($pattern, $secondLine, $matches)) {
                    $inscriptionName = isset($matches[0]) ? $matches[0] : 'ERROR';
                }            
            }

            $this->persistCompanyInscription(
                $inscriptionName ?? null,
                $companyName ?? null,
                $comercialRegistryConstitucion ?? null,
                $inscriptionNumber ?? null,
                $inscriptionSection ?? null,
                $inscriptionCategory ?? null,
                $inscription ?? null,
                $fileName ?? null,
                $bormeDate ?? null,
            );
        }
    }

    public function handleFileTypeB($textoDelPdf, $fileName)
    {
        $inscription = '';

        if (preg_match('/^Otros actos publicados en el Registro Mercantil\n([A-Z\/ÁÉÍÓÚÜ]+)\n/m', $textoDelPdf, $matches)) {
            $comercialRegistryConstitucion = $matches[1];
        }
        
        $this->findBormeVars_A_B($textoDelPdf, $inscriptionCategory, $inscriptions);
        $this->findGenericBormeSectionAndDate($textoDelPdf, $inscriptionSection ,$bormeDate);

        foreach ($inscriptions ?? [] as $key => $inscription) {
            $pattern = "/^\d+\s-\s(.*)(\R|$)/m";
            if (preg_match($pattern, $inscription, $matches)) {
                $companyName = $matches[1];
            } else {
                $companyName = 'Nombre no encontrado';
            }

            if (preg_match("/^\d+/m", $inscription, $matches)) {
                $inscriptionNumber = $matches[0];
            }            
            
            $pattern = "/^(Depósito|Cierre|Reapertura|Cancelación).*/m";
            if (preg_match($pattern, $inscription, $matches)) {
                $inscriptionName = $matches[0] ?? 'ERROR';
            }
            
            $this->persistCompanyInscription(
                $inscriptionName ?? null,
                $companyName ?? null,
                $comercialRegistryConstitucion ?? null,
                $inscriptionNumber ?? null,
                $inscriptionSection ?? null,
                $inscriptionCategory ?? null,
                $inscription ?? null,
                $fileName ?? null,
                $bormeDate ?? null,
            );
        }
    }

    public function handleFileTypeC($textoDelPdf, $fileName)
    {
        $inscription = '';

        // Busca la categoria (Actos inscritos u Otros actos inscritos, etc)
        if (preg_match("/SECCIÓN SEGUNDA - Anuncios y avisos legales\s+(.*)\s+/", $textoDelPdf, $matches)) {
            $inscriptionCategory = $matches[1];
        }

        //Almacena cada acto en un texto plano
        if (preg_match("/^[0-9].*?\d{1,2}\s+de\s+\w+\s+de\s+\d{4}.*?(?=\ncve:)/ms", $textoDelPdf, $matches)) {
            $inscription = $matches[0];
        }

        // Busca la fecha del Borme que estoy procesando
        $this->findGenericBormeSectionAndDate($textoDelPdf, $inscriptionSection ,$bormeDate);

        //TODO: ver que hacer en caso que haya mas de una sociedad, por ej en las fusiones
        // Buscar el nombre de la sociedad
        if (preg_match("/^\d+\s-\s(.*)(?:\n|\r\n)/m", $inscription, $matches)) {
            $companyName = $matches[1];
        }

        //Busca el numero de acto
        if (preg_match("/^\d+/m", $textoDelPdf, $matches)) {
            $inscriptionNumber = $matches[0];
        }

        //Busca el tipo de acto, que luego usaremos para $companyState
        $lineas = explode("\n", $textoDelPdf);

        $inscriptionName = "";

        foreach ($lineas ?? [] as $linea) {
            if (strpos($linea, "Declaración de insolvencia") !== false) {
                $inscriptionName .= $linea . "\n";
            }
            if (strpos($linea, "Disolución de empresas") !== false) {
                $inscriptionName .= $linea . "\n";
            }
            if (strpos($linea, "Pérdida de certificación") !== false) {
                $inscriptionName .= $linea . "\n";
            }
        }

        $this->persistCompanyInscription(
            $inscriptionName ?? null,
            $companyName ?? null,
            $comercialRegistryConstitucion ?? null,
            $inscriptionNumber ?? null,
            $inscriptionSection ?? null,
            $inscriptionCategory ?? null,
            $inscription ?? null,
            $fileName ?? null,
            $bormeDate ?? null,
        );
    }

    public function findGenericBormeSectionAndDate($textoDelPdf, &$inscriptionSection, &$bormeDate) {
        if (preg_match(self::DATE_PATTERN, $textoDelPdf, $matches)) {
            $bormeDate = $matches[0];
        }

        if (preg_match('/Pág\. \d+\n\n(SECCIÓN PRIMERA|SECCIÓN SEGUNDA)/', $textoDelPdf, $matches)) {
            $inscriptionSection = $matches[1];
        }
    }

    public function findBormeVars_A_B($textoDelPdf, &$inscriptionCategory, &$inscriptions) {
        if (preg_match('/Empresarios\s+(.*)\s+/', $textoDelPdf, $matches)) {
            $inscriptionCategory = $matches[1];
        }

        if (preg_match_all('/^([0-9]+ - .*?)(?=\n[0-9]+ - |\z)/ms', $textoDelPdf, $matches)) {
            $inscriptions = $matches[1];
        }
    }

    public function persistCompanyInscription($inscriptionName = null, $companyName = null, $comercialRegistryConstitucion = null, $inscriptionNumber = null, $inscriptionSection = null, $inscriptionCategory = null, $inscription = null, $inscriptionFile = null, $bormeDate = null) {
        $company = $this->entityManager->getRepository(Company::class)->findOneBy(['companySocialDenomination' => $companyName]);

        if (!$company) {
            $company = new Company();
        }

        $company->setCompanyState(self::COMPANY_STATE);
        $company->setCompanySocialDenomination($companyName);
        $company->setCommercialRegistryConstitution($comercialRegistryConstitucion);

        $companyInscription = new CompanyInscription();

        $companyInscription->setInscriptionCommercialRegistry($comercialRegistryConstitucion);
        $companyInscription->setInscriptionNumber($inscriptionNumber);
        $companyInscription->setInscriptionSection($inscriptionSection);
        $companyInscription->setInscriptionCategory($inscriptionCategory);
        $companyInscription->setInscriptionName($inscriptionName);
        $companyInscription->setInscriptionLONGTEXT($inscription);
        $companyInscription->setInscriptionFile($inscriptionFile);
        $companyInscription->setBormeDate($bormeDate);

        $company->addCompanyInscription($companyInscription);
        $this->entityManager->persist($company);
        
        // Limpia la memoria del entity manager
        if (self::$clearCounter % 50 == 0) {
            // Cada 50 persistencias, elimina el contenido del entity manager. Para agilizar el proceso
            $this->entityManager->clear();
            self::$clearCounter = 0;
        }

        self::$clearCounter += 1;
    }

    public function pdfToText($pdfRoute)
    {
        return Pdf::getText($pdfRoute);
    }

    public function noFunc() {}
}